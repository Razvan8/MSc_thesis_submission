print(var(as.vector(y.3w$true)) / (sigma.y ^ 2))
#print("newcolnames")
#print(colnames(x.3w_new))
return(list(
'X' = as.matrix(x.3w_new),
'y' = y.3w,
'beta' = beta.true
))
}
data<- create_data_fisher_test(l1=5,l2=5,l3=5)
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
data<- create_data_fisher_test(l1=3,l2=3,l3=3)
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
data<- create_data_fisher_test(l1=10,l2=10,l3=10)
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
data<- create_data_fisher_test(l1=8,l2=8,l3=8)
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_GLM.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
set.seed(1)
create_fisher_dataset <- function(l1,l2,l2) {
set.seed(1)
x.3w <- dummy.matrix(NF = 3, NL = c(l1+1, l1+2, l1+3))
print(colnames(x.3w))
col_mains <- colnames(x.3w)[c(1:(l1 + l2 + l3))]
#print(col_mains)
col_theta_good <- c()
for (i in c(1:l1)) {
for (j in c(1:l2)) {
# Create the string and append to the vector
col_theta_good <- c(col_theta_good, paste0("A.", i, ":B.", j))
}
for (k in c(1:l3))
{
col_theta_good <- c(col_theta_good, paste0("A.", i, ":C.", k))
}
}
for (j in c(1:l2))
{
for (k in c(1:l3))
{
col_theta_good <- c(col_theta_good, paste0("B.", j, ":C.", k))
}
}
col_psi_good<-c()
for (i in c(1:l1)) {
for (j in c(1:l2)) {
# Create the string and append to the vector
for (k in c(1:l3))
{col_psi_good <- c(col_psi_good, paste0("A.", i, ":B.", j, ":C.", k))
}}}
#print(col_theta_good)
col_all_good = c(col_mains, col_theta_good, col_psi_good)
print(col_all_good)
x.3w<-x.3w[,col_all_good]
print(x.3w)
#print(col_all_good)
# Hierarchical Coefficients (2way)
p.3w <- ncol(x.3w)
n.3w <- p.3w + 1
beta.min <- 2
beta.max <- 5
beta.true <- data.frame(rep(0, n.3w))
rownames(beta.true) <- c("interc", colnames(x.3w))
colnames(beta.true) <- c("coeffs")
set.seed(3)
beta.true$coeffs <- runif(n.3w, beta.min, beta.max) * sample(c(1, -1), size =  n.3w, replace = TRUE)
levs.true <-
c(
"A.1","A.2","A.3","A.4", "A.5", "A.10", "A.11", "A.12",
"B.1","B.2","B.3",
"C.1","C.2","C.3",
"A.1:B.1","A.1:B.2","A.1:B.3", "A.1:C.1", "A.1:C.2", "A.1:C.3",
"A.2:B.1","A.2:B.2", "A.2:C.1", "A.2:C.2", "A.2:C.3",
"A.10:B.1","A.10:B.2","A.10:B.3", "A.10:C.1", "A.10:C.2", "A.10:C.3",
"A.11:B.1","A.11:B.2","A.11:B.3", "A.11:C.1", "A.11:C.2", "A.11:C.3",
"B.1:C.1", "B.1:C.2",
"A.1:B.1:C.1",
"A.2:B.1:C.1",
"A.10:B.1:C.1",
"A.11:B.1:C.1"
)
beta.true$coeffs[which(!is.element(rownames(beta.true), levs.true))] <-0
beta.true$coeffs[2:(2+l1+l2+l3)]<-beta.true$coeffs[2:(2+l1+l2+l3)]+sign(beta.true$coeffs[2:(2+l1+l2+l3)])*3 #mains are from U[4,8]
beta.true$coeffs[1]<- -8
#beta.true_new <-
#beta.true[c("interc", col_all_good), , drop = FALSE]
#print("new beta true")
#print(beta.true_new)
#rownames(beta.true_new) <- c("interc", col_all_good)
#beta.true
#print(beta.true)
# Response vector (2way)
sigma.y <- 0.5
y.3w <- data.frame(row.names = rownames(x.3w))
set.seed(111)
print(mean(
beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]
))
eta=beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]
prob=exp(eta)/(exp(eta)+1)
y.3w$obs <- sample_contbern(p=prob)
y.3w$true <-kappa1(beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]) #get bern
x.3w_new <- x.3w[, col_all_good , drop = FALSE]
if (all(rownames(beta.true)[-1] == colnames(x.3w_new)) == TRUE)
{
print("Data loaded properly")
}
print("SNR:")
print(var(as.vector(y.3w$true)) / (sigma.y ^ 2))
#print("newcolnames")
#print(colnames(x.3w_new))
return(list(
'X' = as.matrix(x.3w_new),
'y' = y.3w,
'beta' = beta.true
))
}
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_GLM.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
set.seed(1)
create_fisher_dataset <- function(l1,l2,l3) {
set.seed(1)
x.3w <- dummy.matrix(NF = 3, NL = c(l1+1, l1+2, l1+3))
print(colnames(x.3w))
col_mains <- colnames(x.3w)[c(1:(l1 + l2 + l3))]
#print(col_mains)
col_theta_good <- c()
for (i in c(1:l1)) {
for (j in c(1:l2)) {
# Create the string and append to the vector
col_theta_good <- c(col_theta_good, paste0("A.", i, ":B.", j))
}
for (k in c(1:l3))
{
col_theta_good <- c(col_theta_good, paste0("A.", i, ":C.", k))
}
}
for (j in c(1:l2))
{
for (k in c(1:l3))
{
col_theta_good <- c(col_theta_good, paste0("B.", j, ":C.", k))
}
}
col_psi_good<-c()
for (i in c(1:l1)) {
for (j in c(1:l2)) {
# Create the string and append to the vector
for (k in c(1:l3))
{col_psi_good <- c(col_psi_good, paste0("A.", i, ":B.", j, ":C.", k))
}}}
#print(col_theta_good)
col_all_good = c(col_mains, col_theta_good, col_psi_good)
print(col_all_good)
x.3w<-x.3w[,col_all_good]
print(x.3w)
#print(col_all_good)
# Hierarchical Coefficients (2way)
p.3w <- ncol(x.3w)
n.3w <- p.3w + 1
beta.min <- 2
beta.max <- 5
beta.true <- data.frame(rep(0, n.3w))
rownames(beta.true) <- c("interc", colnames(x.3w))
colnames(beta.true) <- c("coeffs")
set.seed(3)
beta.true$coeffs <- runif(n.3w, beta.min, beta.max) * sample(c(1, -1), size =  n.3w, replace = TRUE)
levs.true <-
c(
"A.1","A.2","A.3","A.4", "A.5", "A.10", "A.11", "A.12",
"B.1","B.2","B.3",
"C.1","C.2","C.3",
"A.1:B.1","A.1:B.2","A.1:B.3", "A.1:C.1", "A.1:C.2", "A.1:C.3",
"A.2:B.1","A.2:B.2", "A.2:C.1", "A.2:C.2", "A.2:C.3",
"A.10:B.1","A.10:B.2","A.10:B.3", "A.10:C.1", "A.10:C.2", "A.10:C.3",
"A.11:B.1","A.11:B.2","A.11:B.3", "A.11:C.1", "A.11:C.2", "A.11:C.3",
"B.1:C.1", "B.1:C.2",
"A.1:B.1:C.1",
"A.2:B.1:C.1",
"A.10:B.1:C.1",
"A.11:B.1:C.1"
)
beta.true$coeffs[which(!is.element(rownames(beta.true), levs.true))] <-0
beta.true$coeffs[2:(2+l1+l2+l3)]<-beta.true$coeffs[2:(2+l1+l2+l3)]+sign(beta.true$coeffs[2:(2+l1+l2+l3)])*3 #mains are from U[4,8]
beta.true$coeffs[1]<- -8
#beta.true_new <-
#beta.true[c("interc", col_all_good), , drop = FALSE]
#print("new beta true")
#print(beta.true_new)
#rownames(beta.true_new) <- c("interc", col_all_good)
#beta.true
#print(beta.true)
# Response vector (2way)
sigma.y <- 0.5
y.3w <- data.frame(row.names = rownames(x.3w))
set.seed(111)
print(mean(
beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]
))
eta=beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]
prob=exp(eta)/(exp(eta)+1)
y.3w$obs <- sample_contbern(p=prob)
y.3w$true <-kappa1(beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]) #get bern
x.3w_new <- x.3w[, col_all_good , drop = FALSE]
if (all(rownames(beta.true)[-1] == colnames(x.3w_new)) == TRUE)
{
print("Data loaded properly")
}
print("SNR:")
print(var(as.vector(y.3w$true)) / (sigma.y ^ 2))
#print("newcolnames")
#print(colnames(x.3w_new))
return(list(
'X' = as.matrix(x.3w_new),
'y' = y.3w,
'beta' = beta.true
))
}
data<- create_data_fisher_test(l1=9,l2=9,l3=9)
data<- create_fisher_dataeset(l1=9,l2=9,l3=9)
data<- create_fisher_dataset(l1=9,l2=9,l3=9)
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
data<- create_fisher_dataset(l1=7,l2=3,l3=4)
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
data<- create_fisher_dataset(l1=17,l2=3,l3=4)
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
X
X<- data$X
X
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_GLM.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
data<- create_basic_dataset_bern_thesis()
X<- data$X
y<- data$y$obs
y<-array(y, dim=(c(length(y),1)) )
X
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_GLM.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
set.seed(1)
create_fisher_dataset <- function(l1,l2,l3) {
set.seed(1)
x.3w <- dummy.matrix(NF = 3, NL = c(l1+1, l2+1, l3+1))
print(colnames(x.3w))
col_mains <- colnames(x.3w)[c(1:(l1 + l2 + l3))]
#print(col_mains)
col_theta_good <- c()
for (i in c(1:l1)) {
for (j in c(1:l2)) {
# Create the string and append to the vector
col_theta_good <- c(col_theta_good, paste0("A.", i, ":B.", j))
}
for (k in c(1:l3))
{
col_theta_good <- c(col_theta_good, paste0("A.", i, ":C.", k))
}
}
for (j in c(1:l2))
{
for (k in c(1:l3))
{
col_theta_good <- c(col_theta_good, paste0("B.", j, ":C.", k))
}
}
col_psi_good<-c()
for (i in c(1:l1)) {
for (j in c(1:l2)) {
# Create the string and append to the vector
for (k in c(1:l3))
{col_psi_good <- c(col_psi_good, paste0("A.", i, ":B.", j, ":C.", k))
}}}
#print(col_theta_good)
col_all_good = c(col_mains, col_theta_good, col_psi_good)
print(col_all_good)
x.3w<-x.3w[,col_all_good]
print(x.3w)
#print(col_all_good)
# Hierarchical Coefficients (2way)
p.3w <- ncol(x.3w)
n.3w <- p.3w + 1
beta.min <- 2
beta.max <- 5
beta.true <- data.frame(rep(0, n.3w))
rownames(beta.true) <- c("interc", colnames(x.3w))
colnames(beta.true) <- c("coeffs")
set.seed(3)
beta.true$coeffs <- runif(n.3w, beta.min, beta.max) * sample(c(1, -1), size =  n.3w, replace = TRUE)
levs.true <-
c(
"A.1","A.2","A.3","A.4", "A.5", "A.10", "A.11", "A.12",
"B.1","B.2","B.3",
"C.1","C.2","C.3",
"A.1:B.1","A.1:B.2","A.1:B.3", "A.1:C.1", "A.1:C.2", "A.1:C.3",
"A.2:B.1","A.2:B.2", "A.2:C.1", "A.2:C.2", "A.2:C.3",
"A.10:B.1","A.10:B.2","A.10:B.3", "A.10:C.1", "A.10:C.2", "A.10:C.3",
"A.11:B.1","A.11:B.2","A.11:B.3", "A.11:C.1", "A.11:C.2", "A.11:C.3",
"B.1:C.1", "B.1:C.2",
"A.1:B.1:C.1",
"A.2:B.1:C.1",
"A.10:B.1:C.1",
"A.11:B.1:C.1"
)
beta.true$coeffs[which(!is.element(rownames(beta.true), levs.true))] <-0
beta.true$coeffs[2:(2+l1+l2+l3)]<-beta.true$coeffs[2:(2+l1+l2+l3)]+sign(beta.true$coeffs[2:(2+l1+l2+l3)])*3 #mains are from U[4,8]
beta.true$coeffs[1]<- -8
#beta.true_new <-
#beta.true[c("interc", col_all_good), , drop = FALSE]
#print("new beta true")
#print(beta.true_new)
#rownames(beta.true_new) <- c("interc", col_all_good)
#beta.true
#print(beta.true)
# Response vector (2way)
sigma.y <- 0.5
y.3w <- data.frame(row.names = rownames(x.3w))
set.seed(111)
print(mean(
beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]
))
eta=beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]
prob=exp(eta)/(exp(eta)+1)
y.3w$obs <- sample_contbern(p=prob)
y.3w$true <-kappa1(beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]) #get bern
x.3w_new <- x.3w[, col_all_good , drop = FALSE]
if (all(rownames(beta.true)[-1] == colnames(x.3w_new)) == TRUE)
{
print("Data loaded properly")
}
print("SNR:")
print(var(as.vector(y.3w$true)) / (sigma.y ^ 2))
#print("newcolnames")
#print(colnames(x.3w_new))
return(list(
'X' = as.matrix(x.3w_new),
'y' = y.3w,
'beta' = beta.true
))
}
data<- create_fisher_dataset(l1=17,l2=3,l3=4)
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
X
data<- create_fisher_dataset(l1=9,l2=3,l3=4)
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
data<- create_fisher_dataset(l1=10,l2=3,l3=4)
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_GLM.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
data<- create_basic_dataset_bern_thesis()
vals<-eigen(t(X)%*%X)$values
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
data<- create_fisher_dataset(l1=10,l2=2,l3=2)
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_GLM.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
set.seed(1)
create_fisher_dataset <- function(l1,l2,l3) {
set.seed(1)
x.3w <- dummy.matrix(NF = 3, NL = c(l1+1, l2+1, l3+1))
print(colnames(x.3w))
col_mains <- colnames(x.3w)[c(1:(l1 + l2 + l3))]
#print(col_mains)
col_theta_good <- c()
for (i in c(1:l1)) {
for (j in c(1:l2)) {
# Create the string and append to the vector
col_theta_good <- c(col_theta_good, paste0("A.", i, ":B.", j))
}
for (k in c(1:l3))
{
col_theta_good <- c(col_theta_good, paste0("A.", i, ":C.", k))
}
}
for (j in c(1:l2))
{
for (k in c(1:l3))
{
col_theta_good <- c(col_theta_good, paste0("B.", j, ":C.", k))
}
}
col_psi_good<-c()
for (i in c(1:l1)) {
for (j in c(1:l2)) {
# Create the string and append to the vector
for (k in c(1:l3))
{col_psi_good <- c(col_psi_good, paste0("A.", i, ":B.", j, ":C.", k))
}}}
#print(col_theta_good)
col_all_good = c(col_mains, col_theta_good, col_psi_good)
print(col_all_good)
x.3w<-x.3w[,col_all_good]
print(x.3w)
#print(col_all_good)
# Hierarchical Coefficients (2way)
p.3w <- ncol(x.3w)
n.3w <- p.3w + 1
beta.min <- 2
beta.max <- 5
beta.true <- data.frame(rep(0, n.3w))
rownames(beta.true) <- c("interc", colnames(x.3w))
colnames(beta.true) <- c("coeffs")
set.seed(3)
beta.true$coeffs <- runif(n.3w, beta.min, beta.max) * sample(c(1, -1), size =  n.3w, replace = TRUE)
levs.true <-
c(
"A.1","A.2","A.3","A.4", "A.5", "A.10", "A.11", "A.12",
"B.1","B.2","B.3",
"C.1","C.2","C.3",
"A.1:B.1","A.1:B.2","A.1:B.3", "A.1:C.1", "A.1:C.2", "A.1:C.3",
"A.2:B.1","A.2:B.2", "A.2:C.1", "A.2:C.2", "A.2:C.3",
"A.10:B.1","A.10:B.2","A.10:B.3", "A.10:C.1", "A.10:C.2", "A.10:C.3",
"A.11:B.1","A.11:B.2","A.11:B.3", "A.11:C.1", "A.11:C.2", "A.11:C.3",
"B.1:C.1", "B.1:C.2",
"A.1:B.1:C.1",
"A.2:B.1:C.1",
"A.10:B.1:C.1",
"A.11:B.1:C.1"
)
beta.true$coeffs[which(!is.element(rownames(beta.true), levs.true))] <-0
beta.true$coeffs[2:(2+l1+l2+l3)]<-beta.true$coeffs[2:(2+l1+l2+l3)]+sign(beta.true$coeffs[2:(2+l1+l2+l3)])*3 #mains are from U[4,8]
beta.true$coeffs[1]<- -8
#beta.true_new <-
#beta.true[c("interc", col_all_good), , drop = FALSE]
#print("new beta true")
#print(beta.true_new)
#rownames(beta.true_new) <- c("interc", col_all_good)
#beta.true
#print(beta.true)
# Response vector (2way)
sigma.y <- 0.5
y.3w <- data.frame(row.names = rownames(x.3w))
set.seed(111)
print(mean(
beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]
))
eta=beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]
prob=exp(eta)/(exp(eta)+1)
y.3w$obs <- sample_contbern(p=prob)
y.3w$true <-kappa1(beta.true$coeffs[1] + as.matrix(x.3w) %*% as.vector(beta.true$coeffs)[-1]) #get bern
x.3w_new <- x.3w[, col_all_good , drop = FALSE]
if (all(rownames(beta.true)[-1] == colnames(x.3w_new)) == TRUE)
{
print("Data loaded properly")
}
print("SNR:")
print(var(as.vector(y.3w$true)) / (sigma.y ^ 2))
#print("newcolnames")
#print(colnames(x.3w_new))
return(list(
'X' = as.matrix(x.3w_new),
'y' = y.3w,
'beta' = beta.true
))
}
data<- create_fisher_dataset(l1=10,l2=2,l3=2)
X<- data$X
X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
data<- create_fisher_dataset(l1=10,l2=1,l3=1)
X<- data$X
vals<-eigen(t(X)%*%X)$values
print(sort(vals))
X
rownames(X)
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_GLM.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
data<- create_basic_dataset_bern_thesis()
X<- data$X
y<- data$y$obs
y<-array(y, dim=(c(length(y),1)) )
rownames(X)
X[21,]
rownames(X)[21]
rownames(X)[100]
X[100,]
dummy.matrix(NF=3, NL=c(10,2,2))
dummy.matrix(NF=3, NL=c(11,2,2))
